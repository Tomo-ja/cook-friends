import type { GetServerSideProps, NextPage } from "next";
import Head from "next/head";
import * as cookie from 'cookie'


import { useState, useEffect } from "react";

import parseCookies, { popupKeywords, defineExpireDate } from "../helpers";

import SearchKeywordSection from "../components/Home/SearchKeywordSection";
import HeroSection from "../components/Home/heroSection";
import RecipesSectionHome from "../components/Home/recipeSection";

import StyledSEarchSection from "../components/SearchBarSection/index";
import StyledMainContent from "../styles/mainContent.styles";
import StyledSubContent from "../styles/subContent.styles";
import StyledHome from "../components/Home/home.styles";

import { User, RandomRecipes, RecipeInfo, RecipeMinimize, AlertInfo } from "../helpers/typesLibrary";
import appAxios, { spoonacularApiAxios } from "../constants/axiosBase";

import { randomRecipeData } from "../sampleApiData";
import Alert from "../components/Alert";

type Props = {
	user: User | null;
	expireFoods: string[];
	keywords: string[];
	randomRecipes: RecipeMinimize[];
	isFakeData: AlertInfo | null
};

const randomRecipeTags = ["main course", "side dish", "appetizer"];

const Home: NextPage<Props> = ({ user, expireFoods, keywords, randomRecipes, isFakeData}: Props) => {

	const [favoriteRecipes, setFavoriteRecipes] = useState<RecipeMinimize[]>([]);
	const [alert, setAlert] = useState<AlertInfo | null>(isFakeData)

	useEffect(() => {
		if (user === null) {
			return;
		}

		const fetchRecipes = async (ids: string[]) => {
			try {
				const allRes = await Promise.all(
					ids.map(async (id) => {
						// FIXME: url below should be /recipes/${Number(id)}/information
						const response = await spoonacularApiAxios.get(`/recipes/${Number(id)}/info`,{
								params: {
									includeNutrition: false,
								},
						})
						return response.data as RecipeInfo
					})
				)
				setFavoriteRecipes(allRes)
			} catch {
				setFavoriteRecipes([])
			}
		}

		fetchRecipes(user.favoriterecipe.length > 3 ? [...user.favoriterecipe].slice(-3) : user.favoriterecipe)
	}, [])

	return (
		<StyledHome>
			<Head>
				<title>Home | Cookit</title>
				<meta name='description' content='Generated by create next app' />
				<link rel='icon' href='/favicon.ico' />
			</Head>
			<StyledSEarchSection />
			<StyledMainContent>
				<HeroSection randomRecipes={randomRecipes} />

				{favoriteRecipes.length > 0 && (
					<RecipesSectionHome
						title='Favorite Recipes'
						displayRecipes={favoriteRecipes}
						isFavorite={true}
					/>
				)}

			</StyledMainContent>
			<StyledSubContent>
				{expireFoods.length > 0 && (
					<>
						<h3>Expiring Ingredients</h3>
						<SearchKeywordSection keywords={expireFoods} />
					</>
				)}
				<h3>What Is In Your Mind</h3>
				<SearchKeywordSection keywords={keywords} />
			</StyledSubContent>
			{alert && 
				<Alert isError={alert.isError} message={alert.message} setAlert={setAlert} />
			}
		</StyledHome>
	);
};

export default Home;

export const getServerSideProps: GetServerSideProps = async ({ req }) => {
	const cookieData = req.headers.cookie ? cookie.parse(req.headers.cookie) : cookie.parse('')
	const user: User | null = cookieData.user ? JSON.parse(cookieData.user) : null

	const expireFoods: string[] = []
	const keywords = popupKeywords()
	const randomRecipes: RecipeMinimize[] = []
	let isFakeData: AlertInfo | null = null

	if(user) {
		const fridgeData = await appAxios.post("/api/fridge/show", {
			user_id: user.id,
		})
		Object.values(fridgeData.data).forEach((value: any) => {
			if (defineExpireDate(value.stored_at) > 5) {
				expireFoods.push(value.name)
			}
		})
	}

	try{
		const allRes = await Promise.all(
			randomRecipeTags.map(async (tag) => {
				// FIXME: url below should be /recipes/random
				const response = await spoonacularApiAxios.get("/recipes/rando", {
					params: {
						number: 1,
						tags: tag,
					},
				});
				return response.data as RandomRecipes;
			})
		)
		allRes.forEach((recipe) => {
			randomRecipes.push(recipe.recipes[0])
		});
	}catch{
		console.error('fake recipes at random recipes')
		isFakeData = {isError: true, message:'Reached Api call Limitation. Displaying Fake Data'}
		randomRecipeData.forEach(recipe => {
			randomRecipes.push(recipe.recipes[0])
		})
	}

	return {
		props: {
			user,
			expireFoods,
			keywords,
			randomRecipes,
			isFakeData
		}
	}

}
